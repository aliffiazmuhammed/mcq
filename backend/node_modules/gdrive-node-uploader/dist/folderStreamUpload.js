"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.folderStreamUpload = void 0;
const path_1 = __importDefault(require("path"));
const googleapis_1 = require("googleapis");
const stream_1 = require("stream");
const utils_1 = require("./utils");
const findExistingFileId = (drive, name, parentFolderId) => __awaiter(void 0, void 0, void 0, function* () {
    const res = yield drive.files.list({
        q: `name='${name}' and '${parentFolderId}' in parents and trashed=false`,
        fields: 'files(id, name, parents, size, createdTime, modifiedTime, description)'
    });
    return res.data.files.length > 0 ? res.data.files[0] : null;
});
const bufferToStream = (buffer) => {
    const readable = new stream_1.Readable();
    readable._read = () => { };
    readable.push(buffer);
    readable.push(null);
    return readable;
};
const uploadFileFromMemory = (drive, file, folderId) => __awaiter(void 0, void 0, void 0, function* () {
    const fileName = file.name;
    const fileSize = file.buffer.length;
    console.log(`Uploading file: ${fileName}, size: ${fileSize} bytes`);
    const existingFile = yield findExistingFileId(drive, fileName, folderId);
    if (existingFile && Number(existingFile.size) === fileSize) {
        console.log(`File ${fileName} already exists with the same size. Skipping upload.`);
        const downloadUrl = yield (0, utils_1.getFileDownloadUrl)({ drive, fileId: existingFile.id });
        const directDownloadLink = (0, utils_1.convertTodirectDownloadUrl)(downloadUrl);
        return { status: true, fileId: existingFile.id, downloadUrl, directDownloadLink, updated: false };
    }
    const fileMetadata = {
        name: fileName,
        parents: [folderId]
    };
    const media = {
        mimeType: 'application/octet-stream',
        body: bufferToStream(file.buffer) // Convert buffer to readable stream
    };
    let res;
    try {
        if (existingFile) {
            res = yield drive.files.update({
                fileId: existingFile.id,
                requestBody: fileMetadata,
                media,
                fields: 'id'
            });
        }
        else {
            res = yield drive.files.create({
                requestBody: fileMetadata,
                media,
                fields: 'id'
            });
        }
        if (res.data.id) {
            yield (0, utils_1.makeFilePublic)({ drive, fileId: res.data.id });
            const downloadUrl = yield (0, utils_1.getFileDownloadUrl)({ drive, fileId: res.data.id });
            const directDownloadLink = (0, utils_1.convertTodirectDownloadUrl)(downloadUrl);
            console.log(`Uploaded file ${fileName} successfully.`);
            return { status: true, fileId: res.data.id, downloadUrl, directDownloadLink, updated: true };
        }
        else {
            throw new Error('File ID is null or undefined.');
        }
    }
    catch (error) {
        console.error(`Error uploading file ${fileName}:`, error);
        throw error;
    }
});
const createOrUpdateDriveFolder = (drive, folderName, parentFolderId) => __awaiter(void 0, void 0, void 0, function* () {
    console.log(`Creating or updating folder: ${folderName} in parent folder ID: ${parentFolderId}`);
    // Validate the parent folder ID
    try {
        const parentFolder = yield drive.files.get({
            fileId: parentFolderId,
            fields: 'id, name, mimeType'
        });
        if (!parentFolder.data || parentFolder.data.mimeType !== 'application/vnd.google-apps.folder') {
            throw new Error(`Parent folder ID ${parentFolderId} is not a valid folder.`);
        }
    }
    catch (error) {
        console.error(`Error validating parent folder ID ${parentFolderId}:`, error);
        throw error;
    }
    const existingFolder = yield findExistingFileId(drive, folderName, parentFolderId);
    const fileMetadata = {
        name: folderName,
        mimeType: 'application/vnd.google-apps.folder',
        parents: [parentFolderId]
    };
    let res;
    let updated = false;
    try {
        if (existingFolder) {
            res = yield drive.files.update({
                fileId: existingFolder.id,
                requestBody: { name: folderName }, // Only update name
                addParents: parentFolderId,
                removeParents: existingFolder.parents.join(','),
                fields: 'id, webViewLink, createdTime, modifiedTime, description'
            });
            updated = true;
        }
        else {
            res = yield drive.files.create({
                requestBody: fileMetadata,
                fields: 'id, webViewLink, createdTime, modifiedTime, description'
            });
        }
        if (res.data.id) {
            yield (0, utils_1.makeFolderPublic)({ drive, folderId: res.data.id });
            console.log(`Folder ${folderName} created/updated successfully.`);
            return {
                id: res.data.id,
                webViewLink: res.data.webViewLink,
                updated,
                createdTime: res.data.createdTime,
                modifiedTime: res.data.modifiedTime,
                description: res.data.description
            };
        }
        else {
            throw new Error('Failed to create or update folder.');
        }
    }
    catch (error) {
        console.error(`Error creating or updating folder ${folderName}:`, error);
        throw error;
    }
});
const folderStreamUpload = (_a) => __awaiter(void 0, [_a], void 0, function* ({ files, folderName, excludeExtensions = [], parentFolderId = 'root', auth }) {
    if (!files || !folderName || !parentFolderId) {
        throw new Error('No files, folder name, or parent folder ID provided for the folder to upload.');
    }
    const authClient = yield (0, utils_1.getAuthClient)(auth);
    const drive = googleapis_1.google.drive({ version: 'v3', auth: authClient });
    let status = false;
    let message = '';
    let folderId = '';
    let folderUrl = '';
    let updated = false;
    let fileCount = 0;
    let createdTime = '';
    let modifiedTime = '';
    const fileStats = [];
    try {
        const { id, webViewLink, updated: folderUpdated, createdTime: folderCreatedTime, modifiedTime: folderModifiedTime } = yield createOrUpdateDriveFolder(drive, folderName, parentFolderId);
        folderId = id;
        folderUrl = webViewLink;
        updated = folderUpdated;
        createdTime = folderCreatedTime;
        modifiedTime = folderModifiedTime;
        for (const file of files) {
            const fileExtension = path_1.default.extname(file.name).substring(1);
            if (excludeExtensions.includes(fileExtension)) {
                continue;
            }
            const fileResult = yield uploadFileFromMemory(drive, file, folderId);
            updated = updated || fileResult.updated;
            fileCount++;
            const fileId = new URL(fileResult.directDownloadLink).searchParams.get('id');
            fileStats.push({
                fileName: file.name,
                fileSize: file.buffer.length,
                fileType: fileExtension,
                fileUrl: fileResult.directDownloadLink,
                fileId: fileId || ''
            });
        }
        status = true;
        message = 'Folder uploaded or updated successfully.';
    }
    catch (error) {
        message = `Error during folder upload: ${error.message}`;
    }
    return {
        status,
        updated,
        folderId,
        folderUrl,
        folderName,
        fileCount,
        createdTime: (0, utils_1.formatDate)(createdTime),
        modifiedTime: (0, utils_1.formatDate)(modifiedTime),
        message,
        fileStats
    };
});
exports.folderStreamUpload = folderStreamUpload;
//# sourceMappingURL=folderStreamUpload.js.map