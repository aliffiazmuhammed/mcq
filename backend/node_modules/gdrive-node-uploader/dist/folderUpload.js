"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.folderUpload = void 0;
const path_1 = __importDefault(require("path"));
const googleapis_1 = require("googleapis");
const fs_1 = require("fs");
const utils_1 = require("./utils");
const findExistingFileId = (drive, name, parentFolderId) => __awaiter(void 0, void 0, void 0, function* () {
    const res = yield drive.files.list({
        q: `name='${name}' and '${parentFolderId}' in parents and trashed=false`,
        fields: 'files(id, name, parents, size, createdTime, modifiedTime, description)'
    });
    return res.data.files.length > 0 ? res.data.files[0] : null;
});
const getFolderDetails = (drive, folderId) => __awaiter(void 0, void 0, void 0, function* () {
    const res = yield drive.files.list({
        q: `'${folderId}' in parents and trashed=false`,
        fields: 'files(id, name, size, createdTime, modifiedTime)'
    });
    const files = res.data.files || [];
    const fileCount = files.length;
    const totalSize = files.reduce((sum, file) => sum + Number(file.size || 0), 0);
    const createdTime = res.data.files.length > 0 ? files[0].createdTime : '';
    const modifiedTime = res.data.files.length > 0 ? files[0].modifiedTime : '';
    return { fileCount, totalSize, createdTime, modifiedTime };
});
const getLocalFolderDetails = (folderPath_1, ...args_1) => __awaiter(void 0, [folderPath_1, ...args_1], void 0, function* (folderPath, excludeExtensions = []) {
    const entries = yield fs_1.promises.readdir(folderPath, { withFileTypes: true });
    let fileCount = 0;
    let totalSize = 0;
    const fileStats = [];
    for (const entry of entries) {
        const entryPath = path_1.default.join(folderPath, entry.name);
        const fileExtension = path_1.default.extname(entryPath).substring(1);
        if (excludeExtensions.includes(fileExtension)) {
            continue;
        }
        if (entry.isFile()) {
            const stats = yield fs_1.promises.stat(entryPath);
            totalSize += stats.size;
            fileCount++;
            fileStats.push({
                fileName: entry.name,
                filePath: entryPath,
                fileSize: stats.size,
                fileUrl: '',
                fileType: fileExtension,
                downloadUrl: ''
            });
        }
        else if (entry.isDirectory()) {
            const { fileCount: subFileCount, totalSize: subTotalSize, fileStats: subFileStats } = yield getLocalFolderDetails(entryPath, excludeExtensions);
            fileCount += subFileCount;
            totalSize += subTotalSize;
            fileStats.push(...subFileStats);
        }
    }
    return { fileCount, totalSize, fileStats };
});
const uploadFile = (drive, filePath, folderId) => __awaiter(void 0, void 0, void 0, function* () {
    const fileName = path_1.default.basename(filePath);
    const fileSize = (yield fs_1.promises.stat(filePath)).size;
    const existingFile = yield findExistingFileId(drive, fileName, folderId);
    if (existingFile && Number(existingFile.size) === fileSize) {
        const downloadUrl = yield (0, utils_1.getFileDownloadUrl)({ drive, fileId: existingFile.id });
        const directDownloadLink = (0, utils_1.convertTodirectDownloadUrl)(downloadUrl);
        return { status: true, fileId: existingFile.id, downloadUrl, directDownloadLink, updated: false };
    }
    const fileMetadata = {
        name: fileName
    };
    const media = {
        mimeType: 'application/octet-stream',
        body: (yield fs_1.promises.open(filePath, 'r')).createReadStream()
    };
    let res;
    if (existingFile) {
        res = yield drive.files.update({
            fileId: existingFile.id,
            addParents: folderId,
            removeParents: existingFile.parents.join(','),
            requestBody: fileMetadata,
            media,
            fields: 'id'
        });
    }
    else {
        fileMetadata.parents = [folderId];
        res = yield drive.files.create({
            requestBody: fileMetadata,
            media,
            fields: 'id'
        });
    }
    if (res.data.id) {
        yield (0, utils_1.makeFilePublic)({ drive, fileId: res.data.id });
        const downloadUrl = yield (0, utils_1.getFileDownloadUrl)({ drive, fileId: res.data.id });
        const directDownloadLink = (0, utils_1.convertTodirectDownloadUrl)(downloadUrl);
        return { status: true, fileId: res.data.id, downloadUrl, directDownloadLink, updated: true };
    }
    else {
        throw new Error('File ID is null or undefined.');
    }
});
const createOrUpdateDriveFolder = (drive, folderName, description, parentFolderId) => __awaiter(void 0, void 0, void 0, function* () {
    const existingFolder = yield findExistingFileId(drive, folderName, parentFolderId || 'root');
    const fileMetadata = {
        name: folderName,
        mimeType: 'application/vnd.google-apps.folder'
    };
    if (description) {
        fileMetadata.description = description;
    }
    let res;
    let updated = false;
    if (existingFolder) {
        res = yield drive.files.update({
            fileId: existingFolder.id,
            requestBody: fileMetadata,
            fields: 'id, webViewLink, createdTime, modifiedTime, description'
        });
        updated = true;
    }
    else {
        if (parentFolderId) {
            fileMetadata.parents = [parentFolderId];
        }
        res = yield drive.files.create({
            requestBody: fileMetadata,
            fields: 'id, webViewLink, createdTime, modifiedTime, description'
        });
    }
    if (res.data.id) {
        yield (0, utils_1.makeFolderPublic)({ drive, folderId: res.data.id });
        return {
            id: res.data.id,
            webViewLink: res.data.webViewLink,
            updated,
            createdTime: res.data.createdTime,
            modifiedTime: res.data.modifiedTime,
            description: res.data.description
        };
    }
    else {
        throw new Error('Failed to create or update folder.');
    }
});
const folderUpload = (_a) => __awaiter(void 0, [_a], void 0, function* ({ folderPath, description, excludeExtensions = [] }) {
    if (!folderPath) {
        throw new Error('No folder path provided for the folder to upload.');
    }
    const auth = yield (0, utils_1.getAuthClient)();
    const drive = googleapis_1.google.drive({ version: 'v3', auth });
    const folderName = path_1.default.basename(folderPath);
    let status = false;
    let message = '';
    let folderId = '';
    let folderUrl = '';
    let updated = false;
    let fileCount = 0;
    let createdTime = '';
    let modifiedTime = '';
    const fileStats = [];
    try {
        const { id, webViewLink, updated: folderUpdated, createdTime: folderCreatedTime, modifiedTime: folderModifiedTime, description: folderDescription } = yield createOrUpdateDriveFolder(drive, folderName, description);
        folderId = id;
        folderUrl = webViewLink;
        updated = folderUpdated;
        createdTime = folderCreatedTime;
        modifiedTime = folderModifiedTime;
        const existingFolder = yield findExistingFileId(drive, folderName, 'root');
        if (existingFolder) {
            const localFolderDetails = yield getLocalFolderDetails(folderPath, excludeExtensions);
            const driveFolderDetails = yield getFolderDetails(drive, existingFolder.id);
            if (localFolderDetails.fileCount === driveFolderDetails.fileCount && localFolderDetails.totalSize === driveFolderDetails.totalSize) {
                const fileStatsWithUrls = yield Promise.all(localFolderDetails.fileStats.map((file) => __awaiter(void 0, void 0, void 0, function* () {
                    const existingFile = yield findExistingFileId(drive, file.fileName, existingFolder.id);
                    const fileUrl = existingFile ? yield (0, utils_1.getFileDownloadUrl)({ drive, fileId: existingFile.id }) : '';
                    const downloadUrl = fileUrl ? (0, utils_1.convertTodirectDownloadUrl)(fileUrl) : '';
                    return Object.assign(Object.assign({}, file), { fileUrl, downloadUrl });
                })));
                return {
                    status: true,
                    updated: false,
                    folderId,
                    folderUrl,
                    folderName,
                    description: folderDescription,
                    fileCount: driveFolderDetails.fileCount,
                    srcPath: folderPath,
                    createdTime: (0, utils_1.formatDate)(driveFolderDetails.createdTime),
                    modifiedTime: (0, utils_1.formatDate)(driveFolderDetails.modifiedTime),
                    message: 'Folder already exists with the same content.',
                    fileStats: fileStatsWithUrls
                };
            }
        }
        const uploadFolderRecursively = (statusFolderPath, statusFolderId) => __awaiter(void 0, void 0, void 0, function* () {
            const entries = yield fs_1.promises.readdir(statusFolderPath, { withFileTypes: true });
            for (const entry of entries) {
                const entryPath = path_1.default.join(statusFolderPath, entry.name);
                const fileExtension = path_1.default.extname(entryPath).substring(1);
                if (excludeExtensions.includes(fileExtension)) {
                    continue;
                }
                if (entry.isDirectory()) {
                    const subfolder = yield createOrUpdateDriveFolder(drive, entry.name, undefined, statusFolderId);
                    updated = updated || subfolder.updated;
                    yield uploadFolderRecursively(entryPath, subfolder.id);
                }
                else {
                    const fileResult = yield uploadFile(drive, entryPath, statusFolderId);
                    updated = updated || fileResult.updated;
                    fileCount++;
                    fileStats.push({
                        fileName: entry.name,
                        filePath: entryPath,
                        fileSize: (yield fs_1.promises.stat(entryPath)).size,
                        fileUrl: fileResult.downloadUrl,
                        fileType: fileExtension,
                        downloadUrl: fileResult.directDownloadLink
                    });
                }
            }
        });
        yield uploadFolderRecursively(folderPath, folderId);
        // Integrate getFileStats here, avoiding duplicates
        const uploadedFileStats = yield (0, utils_1.getFileStats)(drive, folderId, folderPath);
        const uniqueFileStats = Array.from(new Map(fileStats.map((item) => [item.filePath, item])).values());
        uniqueFileStats.push(...uploadedFileStats);
        status = true;
        message = 'Folder uploaded or updated successfully.';
    }
    catch (error) {
        message = `Error during folder upload: ${error.message}`;
    }
    return {
        status,
        updated,
        folderId,
        folderUrl,
        folderName,
        description,
        fileCount,
        srcPath: folderPath,
        createdTime: (0, utils_1.formatDate)(createdTime),
        modifiedTime: (0, utils_1.formatDate)(modifiedTime),
        message,
        fileStats: Array.from(new Map(fileStats.map((item) => [item.filePath, item])).values()) // Ensure no duplicates
    };
});
exports.folderUpload = folderUpload;
//# sourceMappingURL=folderUpload.js.map